include::issue-footnotes.adoc[]

:fn-mof: footnote:mof[https://en.wikipedia.org/wiki/Meta-Object_Facility[Meta-Object Facility], also known as M3 model]

= LIonWeb Serialization Format

== Conventions used in this document
* _italic_ words refer to concepts defined by JSON.
* *bold* words refer to concepts defined in this document.
* `monospaced` words describe verbatim contents of the serialization.
* Footnotes refer to more discussions and rationale, but are non-normative.

== Design Goals
We do not take any measures to reduce the amount of transmitted data.{fn-org73}


== Description
LIonWeb node serialization format is defined in JSON (https://datatracker.ietf.org/doc/html/rfc8259[RFC 8259]).

=== Root structure

Root level MUST be an _object_ with three members.

##TODO: Are more members allowed?{fn-org67}##

The first member MUST be _key_ `serializationFormatVersion` with a _string_ _value_.{fn-org58}
The value MUST be a decimal integer (without leading or trailing whitespace) describing the serialization format version used to create the processed document, according to <<versions>>.

The second member MUST be _key_ `languages` with an _array_ _value_.{fn-org76}{fn-org78}
Each _element_ in the value array MUST adhere to <<language>>.
The order of _elements_ is undefined.
_elements_ MUST contain all language/version referred to by any <<meta-pointer>> in the processed document.
Each _element_ must be unique with respect to all its _members_.

The third member MUST be _key_ `nodes` with an _array_ _value_.{fn-org33}
Each _element_ in the value array MUST adhere to <<node>>.
The order of _elements_ is undefined.
Each _element_ must be unique with respect to the value of its _key_ `id`.

[[language]]
=== Language structure
Each *used language* MUST be an _object_.
The order of _members_ is undefined.

The _object_ MUST contain the following _members_:{fn-org76}

* _key_ `key` with _string_ _value_, adhering to <<language-key>>.
* _key_ `version` with _string_ _value_, adhering to <<language-version>>.

[[language-key]]
==== Language key
A _string_ according to <<metametamodel.adoc#identifiers, Identifier spec>>.
Refers to the <<metametamodel.adoc#Language.key, key>> of the language.

[[language-version]]
==== Language version
A _string_ with any contents{fn-org128}{fn-org130}, MUST NOT be empty.{fn-org92}
Refers to the <<metametamodel.adoc#Language.version, version>> of the language.

[[meta-pointer]]
=== Meta-pointer
A *meta-pointer* is a reference from M1 to M2.{fn-org89}{fn-mof}
It's used at several places within <<node>>.

Each meta-pointer MUST be an _object_.
The order of _members_ is undefined.

The _object_ MUST contain the following members:

* _key_ `language` with _string_ _value_, adhering to <<language-key>>.
* _key_ `version` with _string_ _value_, adhering to <<language-version>>.
* _key_ `key` with _string_ _value_ according to <<metametamodel.adoc#identifiers, Identifier spec>>.
Refers to some <<metametamodel.adoc#NamespacedEntity, element in the language>>.
Which element exactly is specified for each usage of meta-pointer.

[[node]]
=== Node structure
Each *node* MUST be an _object_.{fn-org37}
The order of _members_ is undefined.

The _object_ MUST contain the following _members_:{fn-org59}{fn-java33}{fn-org55}

* _key_ `id` with _string_ _value_, adhering to <<id>>.
* _key_ `concept`{fn-org37-name} with _object_ _value_, adhering to <<meta-pointer>>.
  The *meta-pointer*'s ``key``'s _value_ refers to the <<metametamodel.adoc#NamespacedEntity.key, *key*>> of the <<metametamodel.adoc#Concept, *Concept*>> this *node* is an instance of.
* _key_ `properties` with _array_ _value_, each _element_ adhering to <<property>>.
The order of _elements_ is undefined.
* _key_ `children`{fn-org55-name-children} with _array_ _value_, each _element_ adhering to <<child>>.
The order of _elements_ is undefined.
* _key_ `references`{fn-org55-name-references} with _array_ _value_, each _element_ adhering to <<reference>>.
The order of _elements_ is undefined.
* _key_ `parent` with _string_ or _null_ _value_, adhering to <<parent>>.

##TODO: How to store invalid text?{fn-org62}##


[[id]]
==== Id value
A _string_ according to <<metametamodel.adoc#identifiers, Identifier spec>>.
Defines the *id* of this *node*.


[[property]]
==== Property
Each *property* MUST be an _object_.
The order of _members_ is undefined.

The _object_ MUST contain the following _members_:

* _key_ `property` with _object_ _value_, adhering to <<meta-pointer>>.
  The *meta-pointer*'s ``key``'s _value_ refers to the <<metametamodel.adoc#NamespacedEntity.key, *key*>> of the <<metametamodel.adoc#Property, *Property*>> this *property* is an instance of.
* _key_ `value` with _value_ as one of
** _string_{fn-org34} containing the value of the property referenced by the `property`.
Refer to <<property-values>> for the specification of the value format.
CAN be an empty _string_.
** _null_ to explicitly specify the property to be unset.


[[child]]
==== Child
Each *child* MUST be an _object_.
The order of _members_ is undefined.

The _object_ MUST contain the following _members_:

* _key_ `containment` with _object_ _value_, adhering to <<meta-pointer>>.
The *meta-pointer*'s ``key``'s _value_ refers to the <<metametamodel.adoc#NamespacedEntity.key, *key*>> of the <<metametamodel.adoc#Containment, *Containment*>> this *child* is an instance of.
* _key_ `children` with _array_ _value_ with _string_ _elements_.
Each _element_ adheres to <<metametamodel.adoc#identifiers, Identifier spec>>, and refers to the *id* of the contained *node*.
The order of _elements_ is undefined.
+
NOTE: Each *child* element is the inverse relation of *parent*.
+
NOTE: The children *node* CAN be contained in the processed document, but also CAN be outside the processed document (i.e. not contained in the processed document).

[[reference]]
==== Reference
Each *reference* MUST be an _object_.
The order of _members_ is undefined.

The _object_ MUST contain the following _members_:

* _key_ `reference` with _object_ _value_, adhering to <<meta-pointer>>.
The *meta-pointer*'s ``key``'s _value_ refers to the <<metametamodel.adoc#NamespacedEntity.key, *key*>> of the <<metametamodel.adoc#Reference, *Reference*>> this *reference* is an instance of.
* _key_ `targets` with __object_ _elements_.
Each _element_ MUST have the following _members_ in undefined order:{fn-org55-name-references}
** _key_ `resolveInfo`{fn-org36} with _value_ as one of:
*** _string_ containing *resolveInfo*, a textual hint that might be used to find the target *node* of this reference.
The exact value depends on the implementation.
CAN be an empty _string_.
*** _null_ if no *resolveInfo* is available.

** _key_ `reference`{fn-org35} with _value_ as one of:
*** _string_ according to <<metametamodel.adoc#identifiers, Identifier spec>>.
Refers to the *id* of the target *node*.
+
NOTE: The referred *node* CAN be contained in the processed document, but also CAN be outside the processed document (i.e. not contained in the processed document).
*** _null_ if the *id* of the target *node* is not known.

[[parent]]
==== Parent
One of

* _string_ according to <<metametamodel.adoc#identifiers, Identifier spec>>.
Refers to the *id* of the *node* containing this *node*.
+
NOTE: *parent* is the inverse relation of one *child*.
+
NOTE: The referred *node* CAN be contained in the processed document, but also CAN be outside the processed document (i.e. not contained in the processed document).

* _null_ if
** This *node* is a *root node*, i.e. this node does not have a parent.
** This serialization is sent as an update request.

[[property-values]]
=== Property serialization
All property values MUST be serialized as JSON _string_.{fn-org34}{fn-org9}.
An unset property CAN be serialized as JSON _null_.

==== String
<<metametamodel.adoc#String, LIonCore Strings>> might be any string, of any length, including (but not limited to):

* empty string: `""`
* only containing whitespace: `" "`
* containing escaped characters as per JSON spec: `"They said:\n \"Hello!\""`
* containing extended Unicode characters: `"üòê"`
* containing escaped Unicode characters: `"\uD83D\uDE10"`

==== Boolean
<<metametamodel.adoc#Boolean, LIonCore Booleans>> MUST be encoded as one of these JSON _strings_:

* `"true"`
* `"false"`

Booleans MUST NOT be encoded with leading or trailing whitespace, uppercase characters, short forms (like `t` or `f`), or decimal representation (like `1`, `0`, `-1`).

==== Integer
<<metametamodel.adoc#Integer, LIonCore Integers>> MUST be encoded as JSON _string_.

* Integers MUST be represented in base-10.
* The digits CAN be prefixed with either `+` (plus) or `-` (minus).{fn-org100}
* Integers MUST NOT be prefixed by leading zeros.
* Integers CAN contain value zero with any prefix, i.e. `0`, `-0`, or `+0`.
* Integers MUST NOT contain leading or trailing whitespace.
* LIonWeb does NOT limit the range of the integer value.
  An implementation MAY refuse a model containing an integer value outside the supported range.
  Every implementation MUST support at least 32 bit signed integer range.
  ##TODO supported integer range?##{fn-org9-intrange}

.Examples of valid Integer encodings

* `"0"`
* `"+0"`
* `"-0"`
* `"123"`
* `"-100000"`
* `"+999"`
* `"100000000200000000300000000400000000500000000600000000700000000800000000900000000999999999"`
* `"-999999999900000000800000000700000000600000000500000000400000000300000000200000000100000000"`

.Examples of invalid Integer encodings

* `""`
* `123`
* `-1`
* `"+-0"`
* `"++1"`
* `"00002"`
* `"0xAA12"`
* `" 5"`
* `"-6 "`

==== JSON
<<metametamodel.adoc#JSON, LIonCore JSON>> MUST be encoded as JSON _string_.
All double quotes, line breaks, etc. MUST be escaped to form a proper JSON _string_.
The value MUST adhere to JSON spec (RFC 8259).

.Valid example
`"{ \"key\": \"my value\",\n\"myArray\": [1, -2, true] }"`

.Invalid example
`{ "key": "my value", "myArray": [1, -2, true] }`

==== Enumeration Literals
<<metametamodel.adoc#EnumerationLiteral, LIonCore Enumeration literals>> MUST be encoded as JSON _string_ _value_ according to <<metametamodel.adoc#identifiers, Identifier spec>>.
MUST refer to the <<metametamodel.adoc#NamespacedEntity.key, key>> of an <<metametamodel.adoc#EnumerationLiteral, EnumerationLiteral>> of the <<metametamodel.adoc#Enumeration, Enumeration>> defined as <<metametamodel.adoc#Property.type, type>> of this *Property*.{fn-org128}

== Examples

=== Minimal
[source,json]
----
{
  "serializationFormatVersion": "1",
  "languages": [],
  "nodes": []
}
----

=== Minimal node
[source,json]
----
{
  "serializationFormatVersion": "1",
  "languages": [
    {
      "key": "myLanguage",
      "version": "2"
    }
  ],
  "nodes": [
    {
      "id": "aaa",
      "concept": {
        "language": "myLanguage",
        "version": "2",
        "key": "myConceptId"
      },
      "properties": {},
      "children": {},
      "references": {},
      "parent": null
    }
  ]
}
----

=== Property variants

For this example, we need to define an enumeration and a concept that uses the enumeration.

NOTE: The format used in this example is non-normative.

Assume this enumeration:
[source]
----
enumeration DaysOfWeek [id 23, key days-of-week]

  literal Monday       [id 34, key monday]
  literal Tuesday      [id 2,  key tttt]
  literal Wednesday    [id 55, key 12398712]
----

And this concept:
[source]
----
concept OpeningTime           [id 44, key time_to_open]
  property day: DaysOfWeek    [id 42, key day]
  property startHour: Integer [id 22, key starthour]
  property endHour: Integer   [id 89, key endhour]
----

[source,json]
----
{
  "serializationFormatVersion": "1",
  "languages": [
    {
      "key": "myLanguage",
      "version": "2"
    }
  ],
  "nodes": [
    {
      "id": "bbb",
      "concept": {
        "language": "myLanguage",
        "version": "2",
        "key": "myConceptId"
      },
      "properties": [
        {
          "property": {
            "language": "myLanguage",
            "version": "2",
            "key": "stringPropertyId"
          },
          "value": "my string value"
        },
        {
          "property": {
            "language": "myLanguage",
            "version": "2",
            "key": "integerPropertyId"
          },
          "value": "123"
        },
        {
          "property": {
            "language": "myLanguage",
            "version": "2",
            "key": "booleanPropertyId"
          },
          "value": "true"
        },
        {
          "property": {
            "language": "myLanguage",
            "version": "2",
            "key": "jsonPropertyId"
          },
          "value": "{ \"name\": \"Bob\" }"
        },
        {
          "property": {
            "language": "myLanguage",
            "version": "2",
            "key": "unsetPropertyId"
          },
          "value": null
        }
      ],
      "children": {},
      "references": {},
      "parent": null
    },
    {
      "id": "21",
      "concept": {
        "language": "myLanguage",
        "version": "2",
        "key": "time_to_open"
      },
      "properties": [
        {
          "property": {
            "language": "myLanguage",
            "version": "2",
            "key": "day"
          },
          "value": "tttt"
        },
        {
          "property": {
            "language": "myLanguage",
            "version": "2",
            "key": "starthour"
          },
          "value": "9"
        },
        {
          "property": {
            "language": "myLanguage",
            "version": "2",
            "key": "endhour"
          },
          "value": "5"
        }
      ],
      "children": [],
      "references": [],
      "parent": null
    }
  ]
}
----

=== Children variants
[source,json]
----
{
  "serializationFormatVersion": "1",
  "languages": [
    {
      "key": "myLanguage",
      "version": "2"
    }
  ],
  "nodes": [
    {
      "id": "ccc",
      "concept": {
        "language": "myLanguage",
        "version": "2",
        "key": "myConceptId"
      },
      "properties": {},
      "children": [
        {
          "containment": {
            "language": "myLanguage",
            "version": "2",
            "key": "emptyContainmentId"
          },
          "children": []
        },
        {
          "containment": {
            "language": "myLanguage",
            "version": "2",
            "key": "singleContainmentId"
          },
          "children": [
            "cdd"
          ]
        },
        {
          "containment": {
            "language": "myLanguage",
            "version": "2",
            "key": "multiContainmentId"
          },
          "children": [
            "cee",
            "cff",
            "cgg"
          ]
        }
      ],
      "references": {},
      "parent": null
    },
    {
      "id": "cgg",
      "concept": {
        "language": "myLanguage",
        "version": "2",
        "key": "differentConceptId"
      },
      "properties": {},
      "children": {},
      "references": {},
      "parent": null
    },
    {
      "id": "cdd",
      "concept": {
        "language": "myLanguage",
        "version": "2",
        "key": "otherConceptId"
      },
      "properties": {},
      "children": {},
      "references": {}
    },
    {
      "id": "cee",
      "concept": {
        "language": "myLanguage",
        "version": "2",
        "key": "differentConceptId"
      },
      "properties": {},
      "children": {},
      "references": {},
      "parent": null
    }
  ]
}
----

*node* with *id* `cff` is outside the processed document.

=== Reference variants
We support different kinds of targets.{fn-org57}
[source,json]
----
{
  "serializationFormatVersion": "1",
  "languages": [
    {
      "key": "myLanguage",
      "version": "2"
    }
  ],
  "nodes": [
    {
      "id": "ddd",
      "concept": {
        "language": "myLanguage",
        "version": "2",
        "key": "myConceptId"
      },
      "properties": {},
      "children": {},
      "references": [
        {
          "reference": {
            "language": "myLanguage",
            "version": "2",
            "key": "emptyReferenceId"
          },
          "targets": []
        },
        {
          "reference": {
            "language": "myLanguage",
            "version": "2",
            "key": "singleReferenceId"
          },
          "targets": [
            {
              "resolveInfo": "some name",
              "reference": "dee"
            }
          ]
        },
        {
          "reference": {
            "language": "myLanguage",
            "version": "2",
            "key": "multiReferenceId"
          },
          "targets": [
            {
              "resolveInfo": "self-reference",
              "reference": "ddd"
            },
            {
              "resolveInfo": "only resolve info",
              "reference": null
            }
          ]
        },
        {
          "reference": {
            "language": "myLanguage",
            "version": "2",
            "key": "noResolveInfoReferenceId"
          },
          "targets": [
            {
              "resolveInfo": null,
              "reference": "dee"
            }
          ]
        },
        {
          "reference": {
            "language": "myLanguage",
            "version": "2",
            "key": "neitherResolveInfoNorReferenceId"
          },
          "targets": [
            {
              "resolveInfo": null,
              "reference": null
            }
          ]
        }
      ],
      "parent": null
    },
    {
      "id": "dee",
      "concept": {
        "language": "myLanguage",
        "version": "2",
        "key": "differentConceptId"
      },
      "properties": {},
      "children": {},
      "references": {},
      "parent": null
    }
  ]
}
----


[[versions]]
== Versions
=== 1
Initial version.


[[possible-values]]
== Possible values for `properties`, `children`, and `references`
Only bold entries are valid.{fn-java33}

[%header,cols="1a,1,1,1"]
|===
|1 A +
Contents
|B +
``properties: {``_ _ _``}``
|C +
``children: {``_ _ _``}``
|D  +
``references: {``_ _ _``}``

|2 `"a": "b"`
|*property with id `a` has value `b`*
.4+.^|`children` value must be array
.4+.^|`references` value must be array

|3 `"c": ""`
|*property with id `c` has value (empty string)*
// |`children` value must be array
// |`references` value must be array

|4 `"d": " "`
|*property with id `d` has value ` `(one space)*
// |`children`value must be array
// |`references`value must be array

|5 `"e": null`
|*property with id `e` has no value*
// |`children` value must be array
// |`references` value must be array

|6 (key `f` not present)
|*property with id `f` has no value*
|*containment with id `f` does not contain any nodes*
|*reference with id `f` does not point to any nodes*

|7 `"g": []`
.9+.^|`properties` value must be string
|*containment with id `g` does not contain any nodes*
|*reference with id `g` does not point to any nodes*

|8 `"h": [ "i" ]`
// |`properties`value must be string
|*containment with id `h` contains node with id`i`*
|`references` value array element must be object

|9

[source%nowrap]
----
"j": [
 {
   "resolveInfo": "k",
   "reference": "l"
 }
]
----
// |`properties` value must be string
.2+.^|`children` value array element must be string
|*reference with id `j` points to node with id `l`, re-binding supported by text `k`*

|10 `"m": [ null ]`
// |`properties` value must be string
// |`children` value array element must be a string
|`references` value array element must be an object

|11 `"n": true`
// |`properties` value must be string
.5+.^|`children` value must be array
.5+.^|`references` value must be array

|12 `"o": 12`
// |`properties` value must be string
// |`children` value must be array
// |`references` value must be array

|13 `"p": 34.56`
// |`properties` value must be string
// |`children` value must be array
// |`references` value must be array

|14 `"q": {}`
// |`properties` value must be string
// |`children` value must be array
// |`references` value must be array

|15 `"r": {`...`}`
// |`properties` value must be string
// |`children` value must be array
// |`references` value must be array

|16 `"s": foo`
3.2+^.^|JSON syntax error
// |JSON syntax error
// |JSON syntax error

|17 `"t": undefined`
// |JSON syntax error
// |JSON syntax error
// |JSON syntax error
|===

[[ref-resolve-null]]
== Meaning and rationale of `null` values for reference id and resolveInfo

Based on{fn-org36-null}

NOTE: We only consider low-level model structure here.
If we had a reference of type `Car`, but the id points to an existing `Wheel`, we would _still_ consider the reference valid on this low level.

In the following matrix, the columns describe _reference_, the rows _resolveInfo_.

reference:

* _valid_ means there it is known that a node with the target id exists.
Undefined whether the targeted node is part of the same model fragment, known locally, or only known to the repository.
* _unknown_ means we don't know whether a node with the target id exists.
* _invalid_ means we know that no node with the target id exists.

resolveInfo:

* _uniquely resolvable_ means that the resolver[1] can find exactly one existing node that could match the given resolve info.
* _ambiguously resolvable_ means that the resolver[1] can find more than one existing node that could match the given resolve info.
* _non-resolvable_ means that the resolver[1] can not find any existing node that could match the given resolve info.

ad [1]: It's currently undefined who the resolver is.
We just assume it can somehow interpret the resolve info, and can return [0..*] valid target nodes.

[%header,cols=">h,<,<,<,<"]
|===
|id &rarr; +
resolveInfo &darr;
^|non-null, valid
^|non-null, unknown
^|non-null, invalid
^|null

|non-null, uniquely resolvable
|happy case
|transient, resolvable
|brittle
|brittle

|non-null, ambiguously resolvable
|mostly happy
|transient
|external selection required
|external selection required

|non-null, non-resolvable
|mostly happy
|transient
|external help required
|external help required

|null
|mostly happy
|transient
|broken
|broken
|===

.Happy case
We know and can reach the target node of the reference.
We also have information how to find the target in case the target is not reachable (e.g. because it has been deleted).

.Transient
We know a target node id, but don't know yet whether that node exists.

.Resolvable
Either through node id or resolveInfo, we're sure we can eventually find our target.

.Brittle
We cannot find the target node by id, but via resolveInfo.
However, resolveInfo might stop working at some point (e.g. if the target gets renamed before resolving the nodeInfo).

.Mostly happy
We know and can reach the target node of the reference.
But we could not re-establish the reference if the target is not reachable (e.g. because the user cuts+pastes the target node, and the pasted one gets a new id).

.External selection required
We don't know the target node.
However, we can present the user with a list of options to chose from.
We populate this list with the potential targets of the resolveInfo.

.External help required
We don't know the target node, and cannot make sense of resolveInfo.
The user might use the resolveInfo to find the actual target.

.Broken
We have no technical way to find the target node, or meaningful ways to support the user to find it.

[NOTE]
====
Instead of the user helping out, we might also infer the same information from language specifics.

Example: Assume a function with only one parameter.
If we had a reference that can only target a parameter, we can infer that target to be the one parameter.
In practice, that means scoping could help us out here (but that's out of scope as of the first remark above).
====