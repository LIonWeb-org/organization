@startuml
title Typed M2 Library Example

skinparam object {
    BackgroundColor<<TypedNode>> LightGreen
    BackgroundColor<<TypedReference>> LightSkyBlue
}
skinparam map {
    BackgroundColor<<TypedProperty>> LightPink
    BackgroundColor<<TypedChild>> LightBlue
}

package meta {
    object "Metamodel" as metamodel

    object "qualifiedName" as qualifiedName
    metamodel *-- qualifiedName

    object MetamodelElement

    object "elements" as elements
    metamodel *-- elements

    object "Concept" as concept

    object "simpleName" as simpleName
    concept *-- simpleName

    object "abstract" as abstract
    concept *-- abstract

    object "features" as features
    concept *-- features

    object "extends" as extends
    concept *-- extends

    object "PrimitiveType" as primitiveType
    primitiveType *-- simpleName

    object "Feature" as Feature

    object "Property" as property
    property *-- simpleName

    object "optional" as optional
    property *-- optional

    object "propertyType" as propertyType
    property *-- propertyType

    object "Reference" as reference
    reference *-- simpleName
    reference *-- optional

    object "multiple" as multiple
    reference *-- multiple

    object "linkType" as linkType
    reference *-- linkType

    object "Containment" as containment
    containment *-- simpleName
    containment *-- optional
    containment *-- multiple
    containment *-- linkType
}

' library (metamodel)

object "<T = Metamodel> library" as library<<TypedNode>> {
    concept = → Metamodel
}
'metamodel <- library #lightgray: concept


map " " as libraryQualifiedName<<TypedProperty>> {
    → qualifiedName => <T = String> "library"
}
library *-- libraryQualifiedName: properties
'qualifiedName <- libraryQualifiedName #lightgray: property

map " " as libraryChildren<<TypedChild>> {
    elements => <T = MetamodelElement*> → elements
}
library *-- libraryChildren: children
'elements <- libraryLibString #lightgray: containment

' LibString

object "<T = PrimitiveType> LibString" as LibString<<TypedNode>> {
    concept = → PrimitiveType
}
'primitiveType <- LibString #lightgray: concept

libraryChildren::elements --> LibString: target

map " " as LibStringName<<TypedProperty>> {
    → simpleName => <T = String> "LibString"
}
LibString *-- LibStringName: properties
'simpleName <- LibStringName #lightgray: property

' LibBoolean

object "<T = PrimitiveType> LibBoolean" as LibBoolean<<TypedNode>> {
    concept = → PrimitiveType
}
'primitiveType <- LibBoolean #lightgray: concept

libraryChildren::elements --> LibBoolean: target

map " " as LibBooleanName<<TypedProperty>> {
    → simpleName => <T = String> "LibBoolean"
}
LibBoolean *-- LibBooleanName: properties
'simpleName <- LibBooleanName #lightgray: property

' LibInteger

object "<T = PrimitiveType> LibInteger" as LibInteger<<TypedNode>> {
    concept = → PrimitiveType
}
'primitiveType <- LibInteger #lightgray: concept

libraryChildren::elements --> LibInteger: target

map " " as LibIntegerName<<TypedProperty>> {
    → simpleName => <T = String> "LibInteger"
}
LibInteger *-- LibIntegerName: properties
'simpleName <- LibIntegerName #lightgray: property

' Book

object "<T = Concept> Book" as Book<<TypedNode>> {
    concept = → Concept
}
'concept <- Book #lightgray: concept

libraryChildren::elements --> Book: target

map " " as bookName<<TypedProperty>> {
    → simpleName => <T = String> "Book"
    → abstract => <T = Boolean> false
}
Book *-- bookName: properties

' Book.title

object "<T = Property> title" as title<<TypedNode>> {
    concept = → Property
}
'property <- title #lightgray: concept

map " " as bookChildren<<TypedChild>> {
     features => <T = Feature*> → features
}
Book *-- bookChildren: children
bookChildren::features -> title: target

map " " as titleName<<TypedProperty>> {
    → simpleName => <T = String> "title"
    → optional => <T = Boolean> false
}
title *-- titleName: properties
'simpleName <- titleName #lightgray: property

object "<T = String>" as titleType<<TypedReference>> {
    reference = → propertyType
}
title *-- titleType: references
'propertyType <- titleType #lightgray: reference
titleType -> LibString: target

' Book.pages

object "<T = Property> pages" as pages<<TypedNode>> {
    concept = → Property
}
'property <- pages #lightgray: concept

bookChildren::features --> pages: target

map " " as pagesName<<TypedProperty>> {
    → SimpleName => <T = String> "pages"
    → optional => <T = Boolean> false
}
pages *-- pagesName: properties
'simpleName <- pagesName #lightgray: property

object "<T = propertyType>" as pagesType<<TypedReference>> {
    reference = → propertyType
}
pages *-- pagesType: references
'propertyType <- pagesType #lightgray: reference
pagesType -> LibInteger: target

' Book.author

object "<T = Reference> author" as author<<TypedNode>> {
    concept = → Reference
}
'reference <- author #lightgray: concept

bookChildren::features --> author: target

map " " as authorName<<TypedProperty>> {
    → simpleName => <T = String> "author"
    → optional => <T = Boolean> false
    → multiple => <T = Boolean> false
}
author *-- authorName: properties
'simpleName <- authorName #lightgray: property


object "<T = linkType>" as authorType<<TypedReference>> {
    reference = → linkType
}
author *-- authorType: references
'linkType <- authorType #lightgray: reference


' Library (node)

object "<T = Concept> Library" as Library<<TypedNode>> {
    concept = → Concept
}
'concept <- Library #lightgray: concept

libraryChildren::elements --> Library: target

map " " as libraryName<<TypedProperty>> {
    → simpleName => <T = String> "Library"
    → abstract => <T = Boolean> false

}
Library *-- libraryName: properties
'simpleName <- libraryName #lightgray: property

' Library.name

object "<T = Property> name" as libraryNameNode<<TypedNode>> {
    concept = → Property
}
'property <- libraryNameNode #lightgray: concept

map " " as LibraryNodeChildren<<TypedChild>> {
     features => <T = Feature*> → features
}
Library *-- LibraryNodeChildren: children
LibraryNodeChildren::features --> libraryNameNode: target

map " " as libraryNameName<<TypedProperty>> {
    → simpleName => <T = String> "name"
    → optional => <T = Boolean> false
}
libraryNameNode *-- libraryNameName: properties
'simpleName <- libraryNameName #lightgray: property

object "<T = propertyType>" as libraryNameNodeType<<TypedReference>> {
    reference = → propertyType
}
libraryNameNode *-- libraryNameNodeType: references
'propertyType <- libraryNameNodeType #lightgray: reference
libraryNameNodeType -> LibString: target

' Library.books

object "<T = Containment> books" as books<<TypedNode>> {
    concept = → Containment
}
'containment <- books #lightgray: concept

LibraryNodeChildren::features --> books: target


map " " as booksName<<TypedProperty>> {
    → simpleName => <T = String> "books"
    → optional => <T = Boolean> false
    → multiple => <T = Boolean> true
}
books *-- booksName: properties
'simpleName <- booksName #lightgray: property

object "<T = linkType>" as booksType<<TypedReference>> {
    reference = → linkType
}
books *-- booksType: references
'linkType <- booksType #lightgray: reference
booksType -> Book: target

' Writer

object "<T = Concept> Writer" as Writer<<TypedNode>> {
    concept = → Concept
}
'concept <- Writer #lightgray: concept


libraryChildren::elements --> Writer: target
authorType -> Writer: target

map " " as Writer_Name<<TypedProperty>> {
    → simpleName => <T = String> "Writer"
    → abstract => <T = Boolean> false
}
Writer *-- Writer_Name: properties
'simpleName <- Writer_Name #lightgray: property

' Writer.name

object "<T = Property> name" as writerName<<TypedNode>> {
    concept = → Property
}
'property <- writerName #lightgray: concept

map " " as WriterChildren<<TypedChild>> {
     features => <T = Feature*> → features
}
Writer *-- WriterChildren: children
WriterChildren::features --> writerName: target

map " " as writerNameName<<TypedProperty>> {
    → simpleName => <T = String> "name"
    → optional => <T = Boolean> false
}
writerName *-- writerNameName: properties
'simpleName <- writerNameName #lightgray: property

object "<T = propertyType>" as writerNameType<<TypedReference>> {
    reference = → propertyType
}
writerName *-- writerNameType: references
'propertyType <- writerNameType #lightgray: reference
writerNameType -> LibString: target

' GuideBookWriter

object "<T = Concept> GuideBookWriter" as GuideBookWriter<<TypedNode>> {
    concept = → Concept
}
'concept <- GuideBookWriter #lightgray: concept

libraryChildren::elements --> GuideBookWriter: target

map " " as GuideBookWriterName<<TypedProperty>> {
    → simpleName => <T = String> "GuideBookWriter"
    → abstract => <T = Boolean> false
}
GuideBookWriter *-- GuideBookWriterName: properties
'simpleName <- GuideBookWriterName #lightgray: property

object "<T = extends>" as GuideBookWriterExtends<<TypedReference>> {
    reference = → extends
}
GuideBookWriter *-- GuideBookWriterExtends: references
'extends <- GuideBookWriterExtends #lightgray: reference
GuideBookWriterExtends -> Writer: target

' GuideBookWriter.countries

object "<T = Property> countries" as countries<<TypedNode>> {
    concept = → Property
}
'simpleName <- countries #lightgray: property

map " " as GuideBookWriterChildren<<TypedChild>> {
     features => <T + Feature*> → features
}
GuideBookWriter *-- GuideBookWriterChildren: children
GuideBookWriterChildren::features -> countries: target

map " " as countriesName<<TypedProperty>> {
    → simpleName => <T = String> "countries"
    → optional => <T = Boolean> false
}
countries *-- countriesName: properties
'simpleName <- countriesName #lightgray: property

object "<T = propertyType>" as countriesType<<TypedReference>> {
    reference = → propertyType
}
countries *-- countriesType: references
'propertyType <- countriesType #lightgray: reference
countriesType -> LibString: target

' SpecialistBookWriter

object "<T = Concept> SpecialistBookWriter" as SpecialistBookWriter<<TypedNode>> {
    concept = → Concept
}
'concept <- SpecialistBookWriter #lightgray: concept

libraryChildren::elements --> SpecialistBookWriter: target

map " " as SpecialistBookWriterName<<TypedProperty>> {
    → simpleName => <T = String> "SpecialistBookWriter"
    → abstract => <T = Boolean> false
}
SpecialistBookWriter *-- SpecialistBookWriterName: properties
'simpleName <- SpecialistBookWriterName #lightgray: property

object "<T = extends>" as SpecialistBookWriterExtends<<TypedReference>> {
    reference = → extends
}
SpecialistBookWriter *-- SpecialistBookWriterExtends: references
'extends <- SpecialistBookWriterExtends #lightgray: reference
SpecialistBookWriterExtends -> Writer: target

' SpecialistBookWriter.subject

object "<T = Property> subject" as subject<<TypedNode>> {
    concept = → Property
}
'simpleName <- subject #lightgray: property

map " " as SpecialistBookWriterChildren<<TypedChild>> {
     features => <T = Feature*> → features
}
SpecialistBookWriter *-- SpecialistBookWriterChildren: children
SpecialistBookWriterChildren::features --> subject: target

map " " as subjectName<<TypedProperty>> {
    → simpleName => <T = String> "subject"
    → optional => <T = Boolean> false
}
subject *-- subjectName: properties
'simpleName <- subjectName #lightgray: property

object "<T = propertyType>" as subjectType<<TypedReference>> {
    reference = → propertyType
}
subject *-- subjectType: references
'propertyType <- subjectType #lightgray: reference
subjectType -> LibString: target

@enduml
