include::../shared/issue-footnotes.adoc[]
:serialization: ../serialization/serialization
:m3: ../metametamodel/metametamodel
= Bulk Repository Access API
:toc: preamble
:toclevels: 2

The bulk API is used to store and retrieve nodes in batches at the moment of invocation.{fn-org25}
It is intended for CRUD operations on (larger) sets of nodes.
it is *not* intended as a delta-oriented API that takes "modification commands" as arguments.

== Use Cases
We describe the use cases from a client's perspective.

* "I'm starting up, which partitions do you know about?", i.e. list possible contents.
* "Here is a node forest, store it as I hand it to you", i.e. actual bulk data storage.
** Sub-case with same behavior: "I'm a very simple client who knows nothing about deltas, so whatever I send you is the truth", i.e. click-save-button.
* "I'm starting up, get me the current partition contents", i.e. initial load.
* "I want to create a guaranteed new node, which id to use?", i.e. retrieval of unused ids.

== Working Hypothesis
Simple bulk API does not need to know the language.{fn-org203}

We assume mapping API is separate from bulk API (variant D){fn-org94}.

We never sent partial nodes.{fn-org211}

#TODO: Do we need a paging parameter?{fn-org204}#

[[apis]]
== APIs

[[partitions, partitions]]
=== partitions: List available partitions
Lists all non-language partitions accessible in the repository.

Calling this API MUST NOT change repository contents.

NOTE: We might add filter capabilities in the future.

==== Parameters
None.

==== Result
<<{serialization}.adoc#SerializationChunk, SerializationChunk>> containing all accessible <<{m3}.adoc#partition, Partitions>> in the Repository.
The partitions are sent as complete nodes.{fn-org202}
Does NOT include <<{m3}.adoc#Language, Languages>> or partition children.

==== Example request
[source, httprequest]
----
GET /bulk/partitions
----

// .Example response
// [source, json]
// ----
// include::partitions.json[]
// ----

[[retrieve, retrieve]]
=== retrieve: Get nodes from repository
Retrieves subtrees nested in the listed node ids.{fn-org201}

Calling this API MUST NOT change repository contents.

NOTE: We might add advanced filtering capabilities in the future, or introduce an additional querying API.

If the repository supports <<trash>>, it MUST retrieve nodes from _trash_ if the client asks for them.

[horizontal]
Jos:: Trash? Didn't see this before.  Doesn't thip open up manu additional questions
- What happens if I create a node with an id of a trahsed node?
Jos:: I don't like the idea that trashed nodes can just be found as any other node.
I would expect an explicit recovery call of some kind. 
Jos:: This might be something to postpone, it makes everything more complex 

==== Parameters
[[retrieve.nodes]]
`nodes`:: List of node ids we want to retrieve from the repository.

[[retrieve.depthLimit]]
`depthLimit`:: Limit the depth of retrieved subtrees.
Optional parameter, defaults to _infinite_.
If present, MUST be an integer >= 0, with
+
--
* 0 meaning "return only the nodes with ids listed in `nodes` parameter",
* 1 meaning "return the nodes with id listed in the `nodes` parameter and their direct children/annotations",
* 2 meaning "return the nodes with id listed in the `nodes` parameter, their direct children/annotations, and the direct children/annotations of these",
* etc.
--
+
NOTE: There's no _magic value_ of `depthLimit` to express _infinite_ depth.
We need to omit the parameter if we don't want to limit the depth.

==== Result
<<{serialization}.adoc#SerializationChunk, SerializationChunk>> containing all nodes according to `nodes` and `depthLimit` parameters.
Does NOT include the definition of <<{serialization}.adoc#UsedLanguage, UsedLanguages>>, only their <<{serialization}.adoc#MetaPointer, MetaPointers>>.

==== Example request
[source, httprequest]
----
GET /bulk/retrieve?mode=direct

[
  "first-node-id",
  "13123123",
  "c2Vjb25kIG5vZGUgaWQ"
]
----

// .Example response
// [source, json]
// ----
// include::partitions.json[]
// ----


[[store, store]]
=== store: Put nodes into repository
Creates new nodes, or updates existing nodes in the repository.

We always process one node in its entirety, i.e. we cannot update parts of the node with this API.

A node id referenced as parent, containment, reference, or annotation _can_ be mentioned in the same request, but _can_ be omitted if a node with that id already exists in the repository.
This way, we can move subtrees and add arbitrary references without sending unchanged nodes.

[horizontal]
Jos:: A node id referenced as parent, containment, reference, or annotation can always be omitted, even if no such node exist. Isn't it?

We consider a node to be _updated_ if a node with the same id already exists in the repository.
Otherwise, we consider that node to be _new_.

==== Parameters
[[store.nodes]]
`nodes`:: <<{serialization}.adoc#SerializationChunk, SerializationChunk>> containing all nodes to store to the repository.

[[store.mode]]
`mode`:: Kind of storage accepted by the repository.
Optional parameter, defaults to `replace`.
[[store.mode.replace, `replace`]]
`replace`::: Accept both new and updated nodes.
[[store.mode.create]]
`create`::: Only accept new nodes.
The call fails without any changes to the repository if any node id from `nodes` already exists in the repository.
The call accepts already existing node ids only referenced as child, reference, or annotation.
[[store.mode.update]]
`update`::: Only accept existing nodes.
The call fails without any changes to the repository if any node id from `nodes` does not exist in the repository.

==== Semantics
After completing this call, all sent nodes MUST have exactly the sent contents (except `parent`, see below #TODO correct?#) in the repository.
We must send containments/annotations from the parent's view, because we need to know the containment and index of the contained node/annotation within its parent.

If we move a contained/annotation node `C` from its previous parent `A` to its new parent `B`, we MUST send both `A` and `B`.
This guarantees no implicit changes to other parts of the model.
If `A` is missing in the input nodes, the whole call fails without any changes to the repository.

The whole call fails, without any changes to the repository, if it would lead to a malformed model (i.e. cycles in containment hierarchy, same node contained in different parents, parent and corresponding containment/annotation don't match #TODO: Add reference to model validation#).
#TODO correct (aka transactional semantics)?#

The repository SHOULD NOT validate the "meta-semantics" of the sent nodes, e.g. whether a Concept instance without parent is a partition, a feature instance can be part of its node instance, or a node mentioned as annotation is an Annotation instance.
Rationale: We want to support storing invalid models, so the user does not lose data.
Also, we assume no knowledge of the metamodel.

[horizontal]
Jos:: The repository should work without metamodel knmowledge, but some kind of correctness will be needed,
otherwise many clients won't work.
We should probably cross-reference with the validation document to see which rules are to be maintained by the repository.
Jos:: If the metamodel is know n, the repository can check many extra things.
That _could_ be beneficiary for all clients. 
Maybe we should have optional validations on the server?

#TODO do we support changes to classifier? What about changes in metapointer.version? Migration use cases?#

#TODO: Do we create new partitions implicitly (by sending a node without parent) or have special call?#


[[orphan]]
.Orphans
An _orphan_ node is a node present in the repository that is not mentioned in any other node as containment or annotation, and is not a partition.
All new orphans SHOULD be moved to a special [[trash, trash]]_trash_ partition in the repository.
Changing nodes within _trash_ fails the whole call without changes to the repository, except if we _recover_ the node.
_Recovering_ means to re-add the orphan node as containment/annotation to a regular node.

If a repository supports _trash_, the repository MAY delete nodes in _trash_ according to its own _garbage collection_ rules (e.g. after some time, or on memory pressure).
If a repository does not support _trash_, it immediately deletes orphans.

The repository MUST NOT update/change references to orphan nodes.
Rationale: We in general do support unresolved or unresolvable references, and changes to the model should always be explicit. #TODO correct?#

.How to handle unknown ids?

* If requested by this client via <<ids>>: Create new node
* If not requested by this client{fn-org94}{fn-org70} #TODO decide#

==== Result
#TODO#

==== Example request
[source, httprequest]
----
POST /bulk/store?mode=replace

TODO request body
----

// .Example response
// [source, json]
// ----
// include::partitions.json[]
// ----


[[delete, delete]]
=== delete: Delete nodes from repository
Deletes nodes from the repository, including <<trash>>.

Deleted nodes don't exist anymore in the repository from the client's point of view.
They might still exist in other contexts (e.g. another branch), or physically within the repository for internal reasons (e.g. storage optimization, concurrent editing support).
After this call succeeds, the deleted nodes MUST NOT appear in any responses according to this API.

Contained/annotation nodes of deleted nodes that are not explicitly mentioned in the call become <<orphan, orphans>> and get treated accordingly (i.e. moved to _trash_, if available).
#TODO do we need a `recursive` parameter?#

After this call succeeds, a repository MAY consider the deleted node's id to be _unused_, and thus allow to re-use it.
A repository also MAY disallow re-using previously deleted node ids.

The whole call fails, without any changes to the repository, if any of the provided node ids does not exist in the repository #TODO correct? What about concurrent deletes?#, or any of the provided node ids is a <<{m3}.adoc#predefined-builtins-keys, built-in id>>.

==== Parameters
[[delete.nodes]]
`nodes`:: List of node ids we want to delete from the repository.

==== Result
#TODO#

==== Example request
[source, httprequest]
----
DELETE /bulk/delete?nodes=["first-node-id","13123123","c2Vjb25kIG5vZGUgaWQ"]
----

[NOTE]
====
link:https://www.rfc-editor.org/rfc/rfc9110.html#name-delete[RFC 9110: HTTP Semantics] states about the request body of a DELETE method:

> An origin server SHOULD NOT rely on private agreements to receive content, since participants in HTTP communication are often unaware of intermediaries along the request chain.

Thus, this example sends the node ids via URL query.

[horizontal]
Jos:: Weird to put them in the URL, instead of the body.
====

[[ids, ids]]
=== ids: Get available ids
Provides unused <<{m3}.adoc#identifiers, valid ids>>.

The repository

* MUST NOT hand out the same unused ids to any other client.
* MAY hand out the same unused ids to the same client more than once.
* MUST NOT contain any node with any of the provided ids.

The ids MUST exclude the <<{m3}.adoc#predefined-builtins-keys, built-in ids>>.

Calling this API MUST NOT change repository contents themselves (besides the internal knowledge of reserved ids).

We don't assume leases, i.e. ids handed out to one client are "owned" by that client forever.
Rationale: Otherwise, the repository must track sessions, and run housekeeping on leases.
This would exclude simple repository implementations.

We assume infinite id space.

#TODO: Take care of DOS attack to deplete id space.#

==== Parameters
[[ids.count]]
`count`:: Number of ids requested.
The repository MUST return between one (inclusive) and `count` (inclusive) ids.
It MAY return less than `count` ids.

==== Result
List of ids guaranteed to be free.

==== Example request
[source, httprequest]
----
GET /bulk/ids?count=10
----

// .Example response
// [source, json]
// ----
// include::partitions.json[]
// ----


== Mapping CRUD operations
NOTE: We assume <<store.mode.replace>> mode.

read:: <<retrieve, retrieve call>> with requested node ids.

create:: <<store, store call>> that sends a node with a <<ids, _new id_>>, including all its features.

update:: <<store, store call>> that sends a node with an _existing id_, including all its features (both updated and unchanged).

delete::
* If node is a Partition: #TODO#
* Otherwise: Assume the to-be-deleted node `D`,  has parent `P`.
+
<<store, store call>> that sends `P` with all its features, but omits `D` from the children/annotations.

move:: Assume we want to move node `N` from its current parent `S` to its new parent `T`.
+
<<store, store call>> that sends `T` with all its features, including `N` in the children.

[horizontal]
Jos:: According to the explanation before `S` should also be sent.
