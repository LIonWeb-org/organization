include::../shared/issue-footnotes.adoc[]
:serialization: ../serialization/serialization
:m3: ../metametamodel/metametamodel
:trash: trash-api
:chunk: <<{serialization}.adoc#SerializationChunk, SerializationChunk>>

= Bulk Repository Access API
:toc: preamble
:toclevels: 2

The bulk API is used to store and retrieve nodes in batches at the moment of invocation.{fn-org25}
It is intended for CRUD operations on (larger) sets of nodes.
it is *not* intended as a delta-oriented API that takes "modification commands" as arguments.

== Use Cases
We describe the use cases from a client's perspective.

* "I'm starting up, which partitions do you know about?", i.e. list possible contents.
* "Let's have a new slate, add a new partition", i.e. partition creation.
* "This part is not needed any more, remove the partition", i.e. partition deletion.
* "Here is a node forest, store it as I hand it to you", i.e. actual bulk data storage.
** Sub-case with same behavior: "I'm a very simple client who knows nothing about deltas, so whatever I send you is the truth", i.e. click-save-button.
* "I'm starting up, get me the current partition contents", i.e. initial load.
* "I want to create a guaranteed new node, which id to use?", i.e. retrieval of unused ids.

== Working Hypothesis
Simple bulk API does not need to know the language.{fn-org203}

#TODO Double-check agreement on invalid models / enforced conformance# {fn-org226}

We do support invalid models w.r.t.{fn-org226}

* Violations of metamodel constraints
* Unresolvable references


We assume mapping API is separate from bulk API (variant D){fn-org94}.

We never sent partial nodes.{fn-org211}

We send commands (with potentially implicit effects), not state updates.

We assume transactional semantics for each command.{fn-org229}

We enforce conformance to{fn-org223}

* Tree structure (i.e. at most one parent for each node)
* Symmetry between containment/annotation and parent
* No unresolvable containment/annotation ids
* No unresolvable parent ids

For now, we do not support paging, as paging tree nodes is non-trivial{fn-org204}

[[apis]]
== APIs

[[partitions, listPartitions]]
=== listPartitions: List available partitions
Lists all non-language partitions accessible in the repository.

Calling this API MUST NOT change repository contents.

NOTE: We might add filter capabilities in the future.

==== Parameters
None.

==== Result

{chunk} containing all accessible <<{m3}.adoc#partition, Partitions>> in the Repository.
The partitions are sent as complete nodes.{fn-org202}
Does NOT include <<{m3}.adoc#Language, Languages>> or partition children.

[[createPartitions, createPartitions]]
=== createPartitions: Create new partitions
Creates new partitions in the repository.{fn-org216}

Each sent node is its own partition.
Thus, we cannot send the contents (i.e. (indirect) annotations/containments) of a partition; We can send them in a later <<store>> call.
We also MUST NOT mention any annotation/containment node ids in the partition nodes, as they cannot be part of the same request, and we don't allow moving nodes in this operation.

We MAY send properties and references #TODO correct?#{fn-org225}

Each partition node id MUST NOT exist in the repository, and the sending client MUST use node ids allocated to it via <<ids>>.

==== Parameters
[[createPartitions.nodes]]
`nodes`:: {chunk} containing  all nodes we want to add as new partitions.

==== Result
#TODO#

[[deletePartitions, deletePartitions]]
=== deletePartitions: Delete partitions and all their contents
Deletes all mentioned partitions, including all (transitive) annotations and children.

All node ids mentions MUST be of partition nodes.

All (transitive) annotations and children become <<orphan, orphans>>.

==== Parameters:
[[deletePartitions.nodeIds]]
`nodeIds`:: List of node ids to delete.

==== Result
#TODO#


[[retrieve, retrieve]]
=== retrieve: Get nodes from repository
Retrieves subtrees nested in the listed node ids.{fn-org201}

Calling this API MUST NOT change repository contents.

NOTE: We might add advanced filtering capabilities in the future, or introduce an additional querying API.

==== Parameters
[[retrieve.nodeIds]]
`nodeIds`:: List of node ids we want to retrieve from the repository.

[[retrieve.depthLimit]]
`depthLimit`:: Limit the depth of retrieved subtrees.
Optional parameter, defaults to _infinite_.
If present, MUST be an integer >= 0, with
+
--
* 0 meaning "return only the nodes with ids listed in `nodeIds` parameter",
* 1 meaning "return the nodes with id listed in the `nodeIds` parameter and their direct children/annotations",
* 2 meaning "return the nodes with id listed in the `nodeIds` parameter, their direct children/annotations, and the direct children/annotations of these",
* etc.
--
+
NOTE: There's no _magic value_ of `depthLimit` to express _infinite_ depth.
We need to omit the parameter if we don't want to limit the depth.

==== Result
{chunk} containing all nodes according to `nodeIds` and `depthLimit` parameters.
Does NOT include the definition of <<{serialization}.adoc#UsedLanguage, UsedLanguages>>, only their <<{serialization}.adoc#MetaPointer, MetaPointers>>.

==== Example request
[source, httprequest]
----
GET /bulk/retrieve?mode=direct

[
  "first-node-id",
  "13123123",
  "c2Vjb25kIG5vZGUgaWQ"
]
----

// .Example response
// [source, json]
// ----
// include::partitions.json[]
// ----


[[store, store]]
=== store: Put nodes into repository
Creates new nodes, or updates existing nodes in the repository.

We always process one node in its entirety, i.e. we cannot update parts of the node with this API.{fn-org211}

A node id referenced as parent, containment, reference, or annotation _can_ be mentioned in the same request, but _can_ be omitted if a node with that id already exists in the repository.
This way, we can move subtrees and add arbitrary references without sending unchanged nodes.

We consider a node to be _updated_ if a node with the same id already exists in the repository.
Otherwise, we consider that node to be _new_.

We do not support different modes.{fn-org230}

==== Parameters
[[store.nodes]]
`nodes`:: {chunk} containing all nodes to store to the repository.

==== Semantics
After completing this call, all sent nodes MUST have exactly the sent contents (except `parent`, see below) in the repository.
We must send containments/annotations from the parent's view, because we need to know the containment and index of the contained node/annotation within its parent.

If we move a contained/annotation node `C` from its previous parent `A` to its new parent `B`, we MUST send `B`, and MAY omit `A`.{fn-org227}
This means we can have implicit changes in `A`.

The whole call fails, without any changes to the repository, if it would lead to a malformed model (i.e. cycles in containment hierarchy, same node contained in different parents, parent and corresponding containment/annotation don't match #TODO: Add reference to model validation#).{fn-org223}

The repository SHOULD NOT #TODO: or MUST NOT?# validate the "meta-semantics" of the sent nodes, e.g. whether a Concept instance without parent is a partition, a feature instance can be part of its node instance, or a node mentioned as annotation is an Annotation instance.{fn-org226}
Rationale: We want to support storing invalid models, so the user does not lose data.
Also, we assume no knowledge of the metamodel.

#TODO do we support changes to classifier? What about changes in metapointer.version? Migration use cases?#{fn-org69}


[[orphan]]
.Orphans
An _orphan_ node is a node present in the repository that is not mentioned in any other node as containment or annotation, and is not a partition.{fn-org219}
We cannot create orphans explicitly.
A node becomes an orphan if it already exists in the repository, but the node's id is removed from its parent containment/annotation,
and the node is not moved to another parent.

#TODO: What about references to orphans? Do they resolve?#

A repository MAY immediately <<delete>> orphans, or keep them in a <<{trash}.adoc, trash>>.

The repository MUST NOT update/change references to orphan nodes.
Rationale: We in general do support unresolved or unresolvable references.

.How to handle unknown ids?

* If requested by this client via <<ids>>: Create new node
* If not requested by this client{fn-org94}{fn-org70} #TODO decide#

==== Result
#TODO#

// ==== Example request
// [source, httprequest]
// ----
// POST /bulk/store?mode=replace
//
// TODO request body
// ----

// .Example response
// [source, json]
// ----
// include::partitions.json[]
// ----


[[delete, delete]]
=== delete: Delete nodes from repository
Deletes nodes from the repository.{fn-org221}

Deleted nodes don't exist anymore in the repository from the client's point of view.
They might still exist in other contexts (e.g. another branch), or physically within the repository for internal reasons (e.g. storage optimization, concurrent editing support).
After this call succeeds, the deleted nodes MUST NOT appear in any responses according to this API.{fn-org220}

If we delete a node, we implicitly remove it from its parent's containment/annotation.

(Transitively) contained/annotation nodes of deleted nodes that are not explicitly mentioned in the call are deleted.

After this call succeeds, a repository MAY consider the deleted node's id to be _unused_, and thus allow to re-use it.
A repository also MAY disallow re-using previously deleted node ids.

The whole call fails, without any changes to the repository, if any of the provided node ids does not exist in the repository, or any of the provided node ids is a <<{m3}.adoc#predefined-builtins-keys, built-in id>>.

==== Parameters
[[delete.nodeIds]]
`nodeIds`:: List of node ids we want to delete from the repository.

==== Result
#TODO#

==== Example request
[source, httprequest]
----
DELETE /bulk/delete?nodes=["first-node-id","13123123","c2Vjb25kIG5vZGUgaWQ"]
----

[NOTE]
====
link:https://www.rfc-editor.org/rfc/rfc9110.html#name-delete[RFC 9110: HTTP Semantics] states about the request body of a DELETE method:

> An origin server SHOULD NOT rely on private agreements to receive content, since participants in HTTP communication are often unaware of intermediaries along the request chain.

Thus, this example sends the node ids via URL query.

====

[[ids, ids]]
=== ids: Get available ids
Provides unused <<{m3}.adoc#identifiers, valid ids>>.

The repository

* MUST NOT hand out the same unused ids to any other client.
* MAY hand out the same unused ids to the same client more than once.
* MUST NOT contain any node with any of the provided ids.

The ids MUST exclude the <<{m3}.adoc#predefined-builtins-keys, built-in ids>>.

Calling this API MUST NOT change repository contents themselves (besides the internal knowledge of reserved ids).

We don't assume leases, i.e. ids handed out to one client are "owned" by that client forever.
Rationale: Otherwise, the repository must track sessions, and run housekeeping on leases.
This would exclude simple repository implementations.

We assume infinite id space.

#TODO: Take care of DOS attack to deplete id space.#

==== Parameters
[[ids.count]]
`count`:: Number of ids requested.
The repository MUST return between one (inclusive) and `count` (inclusive) ids.
It MAY return less than `count` ids.

==== Result
List of ids guaranteed to be free.

==== Example request
[source, httprequest]
----
GET /bulk/ids?count=10
----

// .Example response
// [source, json]
// ----
// include::partitions.json[]
// ----


== Mapping CRUD operations

list:: <<partitions>> for partitions, <<retrieve>> for descendants.

read:: <<retrieve, retrieve call>> with requested node ids (both partitions and other nodes).

create:: <<createPartitions>> for partitions, <<store, store call>> that sends a node with a <<ids, _new id_>>, including all its features.

update:: <<store, store call>> that sends a node (both partitions and other nodes) with an _existing id_, including all its features (both updated and unchanged).

delete:: <<deletePartitions>> for partitions (including all descendants), <<delete>> for other nodes

move:: Assume we want to move node `N` from its current parent `S` to its new parent `T`.
+
<<store, store call>> that sends `T` with all its features, including `N` in the children.
+
NOTE: We cannot move partitions, as we cannot nest them.{fn-org29}
