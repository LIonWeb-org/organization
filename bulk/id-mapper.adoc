= ID Mapping API Idea

*How to read:* First read the use cases _without the implementation part_.
Then read changes, and have a look at the examples.
Finally, investigate the implementation part of use cases.


== Use cases
NOTE: If the repository accepted "made-up" node ids (i.e. Jos' proposal), we can omit the _Bulk.ids_ calls below.

UPDATE::
We parse `StringUtils.java` and create an AST.
All nodes that have a recognizable identity (i.e. can be referred to) have a `fqn` property.
We work with the AST, and refer to some of its "identifiable" nodes from other parts of the model.
+
Some time later, we re-parse `StringUtils.java` because it changed a bit.
We update properties or descendants of changed "identifiable" nodes, add and remove some "identifiable" nodes.
+
--
.Implementation
1. _Bulk.ids_ to get a list of unused ids.
2. _Bulk.store_ with `StringUtils` AST.
3. _Bulk.ids_ to get a list of unused ids.
4. _Bulk.retrieve_ with `idProperty` set, send fqn of `StringUtil` and omit `depth` (i.e. unlimited).
5. For each "identifiable" node in AST, look up node with same fqn in response.
6. _Bulk.store_ with node ids from lookup for changed nodes, node ids from _Bulk.ids_ call for new nodes.

#ISSUE: Step 5 very cumbersome.#
--

DIRECT BIND::
We parse `Main.java`, find a reference to `StringUtils`, and parse `StringUtils.java` in the same parser run.
We build cross-references between `Main` AST and `StringUtils` AST.
+
--
.Implementation
1. _Bulk.ids_ to get a list of unused ids.
2. _Bulk.store_ with `StringUtils`  and `Main` AST, reference to `StringUtils` with `[id=<id of StringUtils>>,resolveInfo=<fqn of StringUtils>]`.
--

PARSE THEN REFER::
We parse `StringUtils.java`, create an AST, and store it in the repository.
+
Some time later, we parse `Main.java`, and build an AST.
It contains a reference to `StringUtils`, which we resolve _without_ re-parsing `StringUtils.java`.
+
--
.Implementation
1. _Bulk.ids_ to get a list of unused ids.
2. _Bulk.store_ with `StringUtils` AST.
3. _Bulk.ids_ to get a list of unused ids.
4. _Bulk.store_ with `Main` AST, reference to `StringUtils` with `[id=null,resolveInfo=<fqn of StringUtils>]`..
5. Invoke _Resolver_ processor.
--

REFER THEN PARSE::
We parse `Main.java`, and find an unresolvable reference to `StringUtils`.
+
Some time later, we parse `StringUtils.java`.
Then we run reference resolution on our model, and establish the reference from `Main` to `StringUtils`.
+
--
.Implementation
1. _Bulk.ids_ to get a list of unused ids.
2. _Bulk.store_ with `Main` AST, reference to `StringUtils` with `[id=null,resolveInfo=<fqn of StringUtils>]`.
3. _Bulk.ids_ to get a list of unused ids.
4. _Bulk.store_ with `StringUtils` AST.
5. Invoke _Resolver_ processor.
--

SEARCH FQN::
We somehow got our hands on a fqn of an "identifiable" node.
We want to know if there is a fitting entry in the repository.
+
--
.Implementation
_Bulk.retrieve_ with `idProperty` set and send fqns instead of node ids.
--

LIST FQNS::
We stored all our "identifiable" nodes in one partition in the repository.
We want to list all of their fqns.
+
--
.Implementation
_Bulk.retrieve_ with partition's node id.
Read `fqn` property of all children of partition.
--

== Changes

1. Define an annotation `Id` on `Property` on M2 level.
We can retrieve nodes via _Bulk.retrieve_ by the value of that property.
We might have a boolean flag `unique` on that annotation, to signal that the value MUST be globally unique.
+
A supporting repository SHOULD create an index for such properties to access them efficiently.
If we supported the `unique` flag, the repository can configure the index accordingly.

2. Define an annotation `ResolveBy` on `Reference` on M2 level.
The annotation has one reference `target` that points to a `Property` with `Id` annotation.
It indicates to a _resolver_ processor to use the value of the `target` Property for resolution.

3. Add another parameter `idProperty` to _Bulk.retrieve_ that contains the key of a Property annotated with `Id`.
Then the `nodes` parameter does not contain node ids, but the value of that property.
+
The result would be the same as always, so we get the node ids and the property with `Id` annotation as usual.


== Example Language
----
Concept Function                   [key=func]
  @Id(unique=true)
  property fqn: String             [key=fully]
  property name: String            [key=naaaam]
  containment body: CodeBlock[1]   [key=myflesh]

Concept FunctionCall extends Expression  [key=fnCall]
  @ResolveBy(target=-> fqn)
  reference function: Function           [key=fnTarget]
----

== Example instance creation
.Instance 1
----
Function [id=123] {
  fqn = "org.apache.commons.lang3.StringUtils.toFirstUpper()"
  name = "toFirstUpper"
  body = StatementList [id=124] { ... }
}
----

.Instance 2
----
Function [id=220] {
  fqn = "com.example.Main.main()"
  name = "main"
  body = StatementList [id=222] {
    FunctionCall [id=432] {
      function = -> [id=null, resolveInfo="org.apache.commons.lang3.StringUtils.toFirstUpper()"]
    }
  }
}
----

== Example Bulk retrieve
.With regular ids
----
GET /bulk/retrieve?depthLimit=5

[
  "123",
  "220"
]
----

.With mapped ids
----
GET /bulk/retrive?depthLimit=5&idProperty=fully

[
  "org.apache.commons.lang3.StringUtils.toFirstUpper()",
  "com.example.Main.main()"
]
----

== Comparison to Bulk API

partitions::
No change: Request doesn't involve any ids, response as usual.

ids::
No change: We never ask for unused mapped ids.

store::
No change in syntax, might have in semantics:
If we allowed `@Id(unique=true)`, the repository MUST reject nodes with the same node id, but different `@Id` property value.

retrieve::
Add another parameter `idProperty` as described above.
Compatible with all other capabilities.
